//bubble sort
//
//idea : 옆에 있는 값과 비교하여 더 작은 값을 앞으로 보내면 어떨까?
//
//버블정렬은 가장 구현하기 쉽지만, 제일 비효율적인 알고리즘
//
//**시간복잡도 : O(N^2)
// 처음에 비교를 하는 배열의 크기는 10이고 첫번째 한바퀴가 돌고 나면, 가장 큰 수가 결정됨
// 다음 비교를 하는 배열의 크기는 9(가장 큰 수가 결정되었으니)이고, 두번째 큰 수가 결정
// 즉 비교횟수는 9 + 8 + 7 + .... + 1
// 이를 N으로 나타내면 총 N*(N+1)/2번의 연산을 함
// ∴ O(N^2)
//
//여기서 궁금증! 왜 버블정렬과 선택정렬 모두 O(N^2)인데, 버블정렬이 더 느릴까?
//-> 버블정렬은 옆의 값과 비교하여 값을 바꾸는 연산을 계속 수행함.
//   그리고 값을 바꾸는 연산은 총 3개의 명령어를 사용하여 실제 컴퓨터의 작업량이 많음
//
//   선택정렬 같은 경우에는 매번 가장 작은 값을 찾아 한번만 값을 바꾸므로 좀 더 빠름!  
//
// ∴ 시간복잡도는 동일하게 O(N^2)이나 실제로 돌려보면 버블정렬은 선택정렬보다 느리다!!!


#include <iostream>
using namespace std;

int main() {
	int i, j, temp;
	int array[10] = {1, 10, 5, 8, 7, 6, 4, 3, 2, 9};

	for (i=0; i<10; i++){
		for (j=0; j<9-i; j++) { //"j<9-i" 왜냐하면 맨 처음 비교하는게 (0,1), (1,2), ... , (8,9) 이므로 j는 0부터 8까지 순회
			if (array[j] > array[j+1]) {
				temp = array[j];
				array[j] = array[j+1];
				array[j+1] = temp;
			}
		}
	}


	//정렬 끝!
	for (i=0; i<10; i++) {
		printf("%d ", array[i]);
	}
	return 0;
}
